<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="python语言特性python是静态还是动态类型？强类型还是弱类型？ 动态强类型语言 动态静态指编译期还是运行期确定类型 强指的是不会发生隐式类型转换，弱相反 ​    JS和PHP就是弱类型语言，例如int类型和string类型相加，不会报错，发生一个隐式转换，把int类型转换成string类型，再输出结果。而python就不会，直接报错typeerror python作为后端语言的优缺点为什">
<meta property="og:type" content="article">
<meta property="og:title" content="python">
<meta property="og:url" content="http://yoursite.com/2020/02/13/python/index.html">
<meta property="og:site_name" content="苏生-Blog">
<meta property="og:description" content="python语言特性python是静态还是动态类型？强类型还是弱类型？ 动态强类型语言 动态静态指编译期还是运行期确定类型 强指的是不会发生隐式类型转换，弱相反 ​    JS和PHP就是弱类型语言，例如int类型和string类型相加，不会报错，发生一个隐式转换，把int类型转换成string类型，再输出结果。而python就不会，直接报错typeerror python作为后端语言的优缺点为什">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-13T13:01:17.000Z">
<meta property="article:modified_time" content="2020-02-14T15:25:12.762Z">
<meta property="article:author" content="苏生">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/02/13/python/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>python | 苏生-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">苏生-Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">只会长大，不会老去。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/13/python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/myhead.jpg">
      <meta itemprop="name" content="苏生">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏生-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-13 21:01:17" itemprop="dateCreated datePublished" datetime="2020-02-13T21:01:17+08:00">2020-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-14 23:25:12" itemprop="dateModified" datetime="2020-02-14T23:25:12+08:00">2020-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="python语言特性"><a href="#python语言特性" class="headerlink" title="python语言特性"></a>python语言特性</h1><p>python是静态还是动态类型？强类型还是弱类型？</p>
<p>动态强类型语言</p>
<p>动态静态指编译期还是运行期确定类型</p>
<p>强指的是不会发生隐式类型转换，弱相反</p>
<p>​    JS和PHP就是弱类型语言，例如int类型和string类型相加，不会报错，发生一个隐式转换，把int类型转换成string类型，再输出结果。而python就不会，直接报错typeerror</p>
<h1 id="python作为后端语言的优缺点"><a href="#python作为后端语言的优缺点" class="headerlink" title="python作为后端语言的优缺点"></a>python作为后端语言的优缺点</h1><p>为什么要用python</p>
<p>​    胶水语言，轮子多，应用广泛</p>
<p>​    语言灵活，生产力高</p>
<p>性能问题，没有静态语言那么好</p>
<p>动态语言的通病，就是代码维护问题，代码重构很吃力</p>
<p>python2/3不兼容</p>
<h1 id="鸭子类型-Duck-typing"><a href="#鸭子类型-Duck-typing" class="headerlink" title="鸭子类型 Duck typing"></a>鸭子类型 Duck typing</h1><p>当一只鸟走起来像鸭子，游起来像鸭子，叫起来也像鸭子，那么这只鸟就可以被称为鸭子</p>
<p>在程序设计中，鸭子类型是动态类型的一种风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定，而是由当前方法和属性的集合决定。在鸭子类型中，关注点在于对象的行为，能做什么，而不是关注对象所属的类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"鸭子 ga ga"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"人也 ga ga"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_the_forest</span><span class="params">(duck)</span>:</span></span><br><span class="line">    duck.quack()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">()</span>:</span></span><br><span class="line">    donald = Duck()</span><br><span class="line">    john = Person()</span><br><span class="line">    in_the_forest(donald)</span><br><span class="line">    in_the_forest(john)</span><br></pre></td></tr></table></figure>

<p>上面实例中，game函数输出的结果里，人和鸭子类型都调用了quack方法，说明它运行时，并不关注对象的类型，而关注对象里是否有quack()这个方法。</p>
<p>而鸭子类型没有任何静态检查，如类型检查，属性检查。</p>
<p>鸭子类型语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常，例如只以会不会gaga叫为标准，一只小狗混进了鸭群，但是这只小狗不会飞，总有一天会出问题。</p>
<h1 id="猴子补丁-Monkey-patch"><a href="#猴子补丁-Monkey-patch" class="headerlink" title="猴子补丁 Monkey patch"></a>猴子补丁 Monkey patch</h1><p>猴子补丁就是在模块运行时替换模块中的某些方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Abc"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"monkey"</span>)</span><br><span class="line"></span><br><span class="line">a = Test()</span><br><span class="line">a.func()</span><br><span class="line">a.func = a.monkey</span><br><span class="line">a.func()</span><br></pre></td></tr></table></figure>

<p>上面代码示例中，调用两次func()，第一次输出“Abc”，第二次输出“monkey”，因为第一次与第一次之间，用monkey替换了func，替换之后运行的func即为monkey。</p>
<p>实际应用：项目开发一半，发现ujson比json性能更高，但是要一个个文件去修改，比较麻烦，可以直接用猴子补丁去替换。</p>
<h1 id="自省-Introspection"><a href="#自省-Introspection" class="headerlink" title="自省 Introspection"></a>自省 Introspection</h1><p>自省机制是什么：自省就是面向对象的语言所写的程序在运行时，能够知道对象的类型，而python的自省机制不仅可以知道对象什么类型，还可以知道对象有哪些属性。</p>
<p>python中常用的自省方法：type()，id()，isinstance()</p>
<h1 id="列表字典推导-语法糖"><a href="#列表字典推导-语法糖" class="headerlink" title="列表字典推导 语法糖"></a>列表字典推导 语法糖</h1><p>比如 [i for i in range(10) if i % 2 == 0]</p>
<p>一种快速生成list/dict/set的方式，用来代替map/filter等</p>
<p>(i for i in range(10) if i% 2 == 0) 返回生成器，节省内存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># d = &#123;'a': 1, 'b': 2, 'c': 3&#125;</span></span><br><span class="line"></span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> zip(a,b)&#125;</span><br></pre></td></tr></table></figure>





<h1 id="进程，线程，协程"><a href="#进程，线程，协程" class="headerlink" title="进程，线程，协程"></a>进程，线程，协程</h1><p>对于操作系统来说，一个任务就是一个进程Process，比如打开一个word就是一个进程，而有些进程不止干同一件事，比如word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为线程。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程，像word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂的交替运行，看起来就像同时执行一样。</p>
<p>多任务的实现有三种方式：</p>
<p>多进程模式</p>
<p>单进程多线程模式</p>
<p>多进程多线程模式</p>
<p>线程是最小的执行单元，而进程由至少一个线程组成，如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<p>多进程的实现</p>
<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = Process(target=xxx, args=(i,))</span><br></pre></td></tr></table></figure>

<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Pool(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p.apply_async(xxx, args=(i,))</span><br></pre></td></tr></table></figure>

<p>Pool(4)指创建4个进程</p>
<p>多线程的实现</p>
<p>python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = threading.Thread(target=xxx)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure>

<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p>
<p>而要防止多个线程同时改一个变量的情况发生，我们需要上锁，即某一个线程在修改的时候，给这个线程上一把锁，上锁之后，其他线程就不能再同时执行修改，直到锁被释放后，获得锁才能修改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure>

<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<p>但是，python的线程虽然是真正的线程，在解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断，比如在执行函数A，B各为一个子程序，在A运行过程中，不调用B，直接中断A执行B，这就是协程的调用。</p>
<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>Python对协程的支持是通过generator实现的。</p>
<p>在generator中，我们不但可以通过<code>for</code>循环来迭代，还可以不断调用<code>next()</code>函数获取由<code>yield</code>语句返回的下一个值。</p>
<p>但是Python的<code>yield</code>不但可以返回一个值，它还可以接收调用者发出的参数。</p>
<p>来看例子：</p>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p>
<p>如果改用协程，生产者生产消息后，直接通过<code>yield</code>跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure>

<p>注意到<code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入<code>produce</code>后：</p>
<ol>
<li>首先调用<code>c.send(None)</code>启动生成器；</li>
<li>然后，一旦生产了东西，通过<code>c.send(n)</code>切换到<code>consumer</code>执行；</li>
<li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回；</li>
<li><code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息；</li>
<li><code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>，整个过程结束。</li>
</ol>
<p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<h1 id="python单元测试Unit-Testing"><a href="#python单元测试Unit-Testing" class="headerlink" title="python单元测试Unit Testing"></a>python单元测试Unit Testing</h1><p>针对程序模块进行正确性检验</p>
<p>单元指最小单元，比如一个函数一个类，自底向上保证程序的正确性</p>
<p>为什么要写单元测试</p>
<p>三无代码不可取（无文档，无注释，无单测）</p>
<p>保证代码逻辑的正确性</p>
<p>单元测试影响设计，易测的代码往往是高内聚低耦合的，即设计好的代码，容易写单元测试</p>
<p>回归测试，防止改一处整个服务不可用</p>
<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><p>深拷贝：b与a指向两个不同的内存地址，但是这两个地址中存储的内容是相同的，修改b的时候，不会影响到a</p>
<p>浅拷贝：b与a同时指向一个内存地址，当b为可变对象时，在修改b的同时，a也会被修改，b为a的浅拷贝，但当b为不可变对象时，修改互不影响</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/12/linux/" rel="prev" title="linux命令">
      <i class="fa fa-chevron-left"></i> linux命令
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/14/mysql/" rel="next" title="mysql">
      mysql <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#python语言特性"><span class="nav-number">1.</span> <span class="nav-text">python语言特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python作为后端语言的优缺点"><span class="nav-number">2.</span> <span class="nav-text">python作为后端语言的优缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#鸭子类型-Duck-typing"><span class="nav-number">3.</span> <span class="nav-text">鸭子类型 Duck typing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#猴子补丁-Monkey-patch"><span class="nav-number">4.</span> <span class="nav-text">猴子补丁 Monkey patch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自省-Introspection"><span class="nav-number">5.</span> <span class="nav-text">自省 Introspection</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#列表字典推导-语法糖"><span class="nav-number">6.</span> <span class="nav-text">列表字典推导 语法糖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程，线程，协程"><span class="nav-number">7.</span> <span class="nav-text">进程，线程，协程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python单元测试Unit-Testing"><span class="nav-number">8.</span> <span class="nav-text">python单元测试Unit Testing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">9.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苏生"
      src="/images/myhead.jpg">
  <p class="site-author-name" itemprop="name">苏生</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苏生</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
