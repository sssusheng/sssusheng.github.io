<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python常用数据结构及实现</title>
    <url>/2020/02/17/python%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python11</title>
    <url>/2020/02/16/python11/</url>
    <content><![CDATA[<h1 id="python算法与数据结构"><a href="#python算法与数据结构" class="headerlink" title="python算法与数据结构"></a>python算法与数据结构</h1><h2 id="内置算法和数据结构"><a href="#内置算法和数据结构" class="headerlink" title="内置算法和数据结构"></a>内置算法和数据结构</h2><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><h3 id="list-tuple-set-dict"><a href="#list-tuple-set-dict" class="headerlink" title="list tuple set dict"></a>list tuple set dict</h3><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>链表</p>
<p>单链表</p>
<p>双链表</p>
<p>循环双端链表</p>
<p>队列</p>
<p>栈</p>
<p>二叉树</p>
<p>堆</p>
]]></content>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/02/14/mysql/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python</title>
    <url>/2020/02/13/python/</url>
    <content><![CDATA[<h1 id="python语言特性"><a href="#python语言特性" class="headerlink" title="python语言特性"></a>python语言特性</h1><p>python是静态还是动态类型？强类型还是弱类型？</p>
<p>动态强类型语言</p>
<p>动态静态指编译期还是运行期确定类型</p>
<p>强指的是不会发生隐式类型转换，弱相反</p>
<p>​    JS和PHP就是弱类型语言，例如int类型和string类型相加，不会报错，发生一个隐式转换，把int类型转换成string类型，再输出结果。而python就不会，直接报错typeerror</p>
<h1 id="python作为后端语言的优缺点"><a href="#python作为后端语言的优缺点" class="headerlink" title="python作为后端语言的优缺点"></a>python作为后端语言的优缺点</h1><p>为什么要用python</p>
<p>​    胶水语言，轮子多，应用广泛</p>
<p>​    语言灵活，生产力高</p>
<p>性能问题，没有静态语言那么好</p>
<p>动态语言的通病，就是代码维护问题，代码重构很吃力</p>
<p>python2/3不兼容</p>
<h1 id="鸭子类型-Duck-typing"><a href="#鸭子类型-Duck-typing" class="headerlink" title="鸭子类型 Duck typing"></a>鸭子类型 Duck typing</h1><p>当一只鸟走起来像鸭子，游起来像鸭子，叫起来也像鸭子，那么这只鸟就可以被称为鸭子</p>
<p>在程序设计中，鸭子类型是动态类型的一种风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口决定，而是由当前方法和属性的集合决定。在鸭子类型中，关注点在于对象的行为，能做什么，而不是关注对象所属的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"鸭子 ga ga"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"人也 ga ga"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_the_forest</span><span class="params">(duck)</span>:</span></span><br><span class="line">    duck.quack()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">()</span>:</span></span><br><span class="line">    donald = Duck()</span><br><span class="line">    john = Person()</span><br><span class="line">    in_the_forest(donald)</span><br><span class="line">    in_the_forest(john)</span><br></pre></td></tr></table></figure>

<p>上面实例中，game函数输出的结果里，人和鸭子类型都调用了quack方法，说明它运行时，并不关注对象的类型，而关注对象里是否有quack()这个方法。</p>
<p>而鸭子类型没有任何静态检查，如类型检查，属性检查。</p>
<p>鸭子类型语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常，例如只以会不会gaga叫为标准，一只小狗混进了鸭群，但是这只小狗不会飞，总有一天会出问题。</p>
<h1 id="猴子补丁-Monkey-patch"><a href="#猴子补丁-Monkey-patch" class="headerlink" title="猴子补丁 Monkey patch"></a>猴子补丁 Monkey patch</h1><p>猴子补丁就是在模块运行时替换模块中的某些方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Abc"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monkey</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"monkey"</span>)</span><br><span class="line"></span><br><span class="line">a = Test()</span><br><span class="line">a.func()</span><br><span class="line">a.func = a.monkey</span><br><span class="line">a.func()</span><br></pre></td></tr></table></figure>

<p>上面代码示例中，调用两次func()，第一次输出“Abc”，第二次输出“monkey”，因为第一次与第一次之间，用monkey替换了func，替换之后运行的func即为monkey。</p>
<p>实际应用：项目开发一半，发现ujson比json性能更高，但是要一个个文件去修改，比较麻烦，可以直接用猴子补丁去替换。</p>
<h1 id="自省-Introspection"><a href="#自省-Introspection" class="headerlink" title="自省 Introspection"></a>自省 Introspection</h1><p>自省机制是什么：自省就是面向对象的语言所写的程序在运行时，能够知道对象的类型，而python的自省机制不仅可以知道对象什么类型，还可以知道对象有哪些属性。</p>
<p>python中常用的自省方法：type()，id()，isinstance()</p>
<h1 id="列表字典推导-语法糖"><a href="#列表字典推导-语法糖" class="headerlink" title="列表字典推导 语法糖"></a>列表字典推导 语法糖</h1><p>比如 [i for i in range(10) if i % 2 == 0]</p>
<p>一种快速生成list/dict/set的方式，用来代替map/filter等</p>
<p>(i for i in range(10) if i% 2 == 0) 返回生成器，节省内存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># d = &#123;'a': 1, 'b': 2, 'c': 3&#125;</span></span><br><span class="line"></span><br><span class="line">d = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> zip(a,b)&#125;</span><br></pre></td></tr></table></figure>





<h1 id="进程，线程，协程"><a href="#进程，线程，协程" class="headerlink" title="进程，线程，协程"></a>进程，线程，协程</h1><p>对于操作系统来说，一个任务就是一个进程Process，比如打开一个word就是一个进程，而有些进程不止干同一件事，比如word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个子任务，我们把进程内的这些子任务称为线程。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程，像word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂的交替运行，看起来就像同时执行一样。</p>
<p>多任务的实现有三种方式：</p>
<p>多进程模式</p>
<p>单进程多线程模式</p>
<p>多进程多线程模式</p>
<p>线程是最小的执行单元，而进程由至少一个线程组成，如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<p>多进程的实现</p>
<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Process(target=xxx, args=(i,))</span><br></pre></td></tr></table></figure>

<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Pool(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p.apply_async(xxx, args=(i,))</span><br></pre></td></tr></table></figure>

<p>Pool(4)指创建4个进程</p>
<p>多线程的实现</p>
<p>python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = threading.Thread(target=xxx)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br></pre></td></tr></table></figure>

<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p>
<p>而要防止多个线程同时改一个变量的情况发生，我们需要上锁，即某一个线程在修改的时候，给这个线程上一把锁，上锁之后，其他线程就不能再同时执行修改，直到锁被释放后，获得锁才能修改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure>

<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>
<p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</p>
<p>但是，python的线程虽然是真正的线程，在解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断，比如在执行函数A，B各为一个子程序，在A运行过程中，不调用B，直接中断A执行B，这就是协程的调用。</p>
<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>Python对协程的支持是通过generator实现的。</p>
<p>在generator中，我们不但可以通过<code>for</code>循环来迭代，还可以不断调用<code>next()</code>函数获取由<code>yield</code>语句返回的下一个值。</p>
<p>但是Python的<code>yield</code>不但可以返回一个值，它还可以接收调用者发出的参数。</p>
<p>来看例子：</p>
<p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p>
<p>如果改用协程，生产者生产消息后，直接通过<code>yield</code>跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure>

<p>注意到<code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入<code>produce</code>后：</p>
<ol>
<li>首先调用<code>c.send(None)</code>启动生成器；</li>
<li>然后，一旦生产了东西，通过<code>c.send(n)</code>切换到<code>consumer</code>执行；</li>
<li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回；</li>
<li><code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息；</li>
<li><code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>，整个过程结束。</li>
</ol>
<p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<h1 id="python单元测试Unit-Testing"><a href="#python单元测试Unit-Testing" class="headerlink" title="python单元测试Unit Testing"></a>python单元测试Unit Testing</h1><p>针对程序模块进行正确性检验</p>
<p>单元指最小单元，比如一个函数一个类，自底向上保证程序的正确性</p>
<p>为什么要写单元测试</p>
<p>三无代码不可取（无文档，无注释，无单测）</p>
<p>保证代码逻辑的正确性</p>
<p>单元测试影响设计，易测的代码往往是高内聚低耦合的，即设计好的代码，容易写单元测试</p>
<p>回归测试，防止改一处整个服务不可用</p>
<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><p>深拷贝：b与a指向两个不同的内存地址，但是这两个地址中存储的内容是相同的，修改b的时候，不会影响到a</p>
<p>浅拷贝：b与a同时指向一个内存地址，当b为可变对象时，在修改b的同时，a也会被修改，b为a的浅拷贝，但当b为不可变对象时，修改互不影响</p>
]]></content>
  </entry>
  <entry>
    <title>linux命令</title>
    <url>/2020/02/12/linux/</url>
    <content><![CDATA[<p>ps aux|grep nginx</p>
<p>pkill -f uwsgi</p>
]]></content>
  </entry>
  <entry>
    <title>Nginx+uWSGI在CentOS7上部署Django项目</title>
    <url>/2020/02/12/nginx/</url>
    <content><![CDATA[<h1 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么"></a>Nginx是什么</h1><p>​        对于大多数使用者来说，Nginx只是一个静态文件服务器或者http请求转发器，对于静态文件的请求它可以直接返回静态文件资源，把动态文件的请求转发给后台的处理程序。</p>
<p>1.浏览器向Nginx发送App的URL</p>
<p>2.Nginx转发请求给服务器中的App</p>
<p>3.App把输出结果返回给Nginx</p>
<p>4.Nginx把输出结果返回给浏览器</p>
<h1 id="uWSGI是什么"><a href="#uWSGI是什么" class="headerlink" title="uWSGI是什么"></a>uWSGI是什么</h1><p>​        web服务器和web框架之间可以互相搭配使用的前提，就是满足WSGI协议，而uWSGI就是实现了WSGI协议的一个web服务器，即用来接收客户端请求，转发相应的程序。</p>
<p>​        一个普通的个人网站，访问量不大的话，当然可以由uWSGI和Django构成。但是一旦访问量过大，客户端请求连接就要进行长时间的等待。这个时候就出来了分布式服务器，我们可以多来几台web服务器，都能处理请求。但是谁来分配客户端的请求连接和web服务器呢？Nginx就是这样一个管家的存在，由它来分配。这也就是由Nginx实现反向代理，即代理服务器。</p>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之数组(Array)</title>
    <url>/2020/02/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84(Array)/</url>
    <content><![CDATA[<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><h2 id="最基础的数组"><a href="#最基础的数组" class="headerlink" title="最基础的数组"></a>最基础的数组</h2><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><p>​        数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据，在定义时需要预先指定大小。</p>
<a id="more"></a>

<blockquote>
<p>线性表(Linear List中)，线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。</p>
<p>连续的内存空间和相同类型的数据，这两个限制，使得数组可以实现随机访问的特性，但也使很多操作变得低效，比如在数组中插入、删除一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
</blockquote>
<h3 id="数组的操作的及实现"><a href="#数组的操作的及实现" class="headerlink" title="数组的操作的及实现"></a>数组的操作的及实现</h3><p>我们假设有一个数组a，长度为n。</p>
<h4 id="根据下标随机访问"><a href="#根据下标随机访问" class="headerlink" title="根据下标随机访问"></a>根据下标随机访问</h4><p>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)</p>
<p>原理实现：计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会通过寻址公式，计算出该元素存储的内存地址，然后根据得到的内存地址，访问对应的元素，即通过计算偏移量就能取得元素，而不必遍历所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 寻址公式</span></span><br><span class="line"><span class="comment"># base_address 起始地址</span></span><br><span class="line"><span class="comment"># data_type_size 数组中每个元素的大小，数组只能存储同类型元素，所以每个元素的大小是相等的</span></span><br><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>排好序的数组，查找元素用二分查找，时间复杂度为O(logn)</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设现在我们需要将一个数据插入到数组中的第k个位置。</p>
<blockquote>
<p>如果数组是有序的，为了把第k个位置腾出来给新来的元素，我们需要将第k~n这部分的元素都顺序的往后挪一位，时间复杂度为O(n)；</p>
<p>如果数组是无序的，为了避免大规模的数据搬移，我们可以直接把第k位的数据搬移到数组元素的最后，把新的元素放入第k个位置，时间复杂度为O(1)</p>
</blockquote>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>与插入操作类似，把第k个位置的元素删除，为了内存的连续性，也需要搬移数据。</p>
<p>特殊处理：将多次删除的操作集中在一起执行，就不用每删除一个元素就搬移一次数据，而总共只需要搬移一次数据。</p>
<h2 id="python中的列表list"><a href="#python中的列表list" class="headerlink" title="python中的列表list"></a>python中的列表list</h2><p>python中也有Array类，但是因为其只能存同一类型数据，且只能存基础类型的数据，使用并不广泛。替代Array类进行日常开发使用的，是list类型。</p>
<h3 id="list常用内置方法"><a href="#list常用内置方法" class="headerlink" title="list常用内置方法"></a>list常用内置方法</h3><ul>
<li>list[index]    按下标访问元素，时间复杂度O(1)</li>
<li>list.append(obj)    在列表末尾添加新的对象，O(1)</li>
<li>list.insert(index, obj)    在指定位置插入对象，O(n)</li>
<li>list.pop(index)    默认删除最后一位，O(1)，不是最后一位则为O(n)</li>
<li>list.remove(obj)    删除指定元素，O(n)</li>
</ul>
<h3 id="list的特点"><a href="#list的特点" class="headerlink" title="list的特点"></a>list的特点</h3><ol>
<li>列表可以存储不同类型的数据，它存储元素的方法是使用元素外置的方式，即存储的只是各个元素的地址，所以列表中的元素可以是不同类型的。</li>
<li>不必在定义时就指定大小，使用了动态扩容的策略。在python中，列表初始化时会申请一个存储四个元素的存储区，当存储区填满时，列表会再次申请四个存储空间存储元素。当元素量达到原存储空间的两倍时，列表会再次申请原来旧的存储空间的两倍的容量存储元素。</li>
</ol>
<h3 id="借用list实现一个Array-ADT"><a href="#借用list实现一个Array-ADT" class="headerlink" title="借用list实现一个Array ADT"></a>借用list实现一个Array ADT</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size=<span class="number">32</span>)</span>:</span></span><br><span class="line">        self._size = size</span><br><span class="line">        self._items = [<span class="literal">None</span>] * size</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[index]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        self._items[index] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self, value=None)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self._items)):</span><br><span class="line">            self._items[i] = value</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._items:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">10</span></span><br><span class="line">    a = Array(size)</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> a[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">assert</span> a[<span class="number">0</span>] <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
