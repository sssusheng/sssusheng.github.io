<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python高级排序算法(一)</title>
    <url>/2020/02/17/python%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95(%E4%B8%80)/</url>
    <content><![CDATA[<p>​        高级排序算法的原理及实现：归并排序(merge_sort)，快速排序(quick_sort)。</p>
<a id="more"></a>

<h1 id="高级排序算法"><a href="#高级排序算法" class="headerlink" title="高级排序算法"></a>高级排序算法</h1><p>很多有用的算法结构上是递归的，为了解决一个特定问题，算法一次或者多次递归调用其自身以解决若干子问题。<br>这些算法典型地遵循分治法的思想：将原问题分解为几个规模较小但是类似于原问题的子问题，递归求解这些子问题，<br>然后再合并这些问题的解来建立原问题的解。</p>
<p>分治法在每层递归时有三个步骤：</p>
<ul>
<li><strong>分解</strong>原问题为若干子问题，这些子问题是原问题的规模最小的实例</li>
<li><strong>解决</strong>这些子问题，递归地求解这些子问题。当子问题的规模足够小，就可以直接求解</li>
<li><strong>合并</strong>这些子问题的解成原问题的解</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="思想原理"><a href="#思想原理" class="headerlink" title="思想原理"></a>思想原理</h3><p>归并排序是是如何利用分治法解决问题的。</p>
<ul>
<li><strong>分解</strong>：将待排序的 n 个元素分成各包含 n/2 个元素的子序列</li>
<li><strong>解决</strong>：使用归并排序递归排序两个子序列</li>
<li><strong>合并</strong>：合并两个已经排序的子序列以产生已排序的答案</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    left = merge_sort(seq[:mid])</span><br><span class="line">    right = merge_sort(seq[mid:])</span><br><span class="line"></span><br><span class="line">    new_seq = merge_sort_list(left, right)</span><br><span class="line">    <span class="keyword">return</span> new_seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_list</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    l_len = len(left)</span><br><span class="line">    r_len = len(right)</span><br><span class="line">    a = b = <span class="number">0</span></span><br><span class="line">    new_seq = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a &lt; l_len <span class="keyword">and</span> b &lt; r_len:</span><br><span class="line">        <span class="keyword">if</span> left[a] &lt; right[b]:</span><br><span class="line">            new_seq.append(left[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_seq.append(right[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> a &lt; l_len:</span><br><span class="line">        new_seq.append(left[a])</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; r_len:</span><br><span class="line">        new_seq.append(right[b])</span><br><span class="line">        b += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> new_seq</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="思想原理-1"><a href="#思想原理-1" class="headerlink" title="思想原理"></a>思想原理</h3><p>和归并排序一样，快排也是一种分而治之(divide and conquer)的策略。归并排序把数组递归成只有单个元素的数组，之后再不断两两合并，最后得到一个有序数组。这里的递归基本条件就是只包含一个元素的数组，当数组只包含一个元素的时候，我们可以认为它本来就是有序的（当然空数组也不用排序）。</p>
<p>快排的工作过程其实比较简单，三步走：</p>
<ul>
<li>选择基准值 pivot 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。这个过程称之为 partition</li>
<li>对这两个子数组进行快速排序。</li>
<li>合并结果</li>
</ul>
<p>但是，下面代码中第一个快排的实现并不优秀，他占用了额外的存储空间，且遍历了两次数组；能否实现只遍历一次数组就可以完成 partition 操作呢？</p>
<blockquote>
<p>实际上是可以的。我们设置首位俩个指针 left, right，两个指针不断向中间收拢；如果遇到 left 位置的元素大于 pivot 并且 right 指向的元素小于 pivot，我们就交换这俩元素；</p>
<p>当 left &gt; right 的时候退出就行了，这样实现了一次遍历就完成了 partition。</p>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    p = seq[<span class="number">0</span>]</span><br><span class="line">    small_seq = [i <span class="keyword">for</span> i <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> i &lt; p]</span><br><span class="line">    big_seq = [i <span class="keyword">for</span> i <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> i &gt;= p]</span><br><span class="line">    new_seq = small_seq + [p] + big_seq</span><br><span class="line">    <span class="keyword">return</span> new_seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(seq, beg, end)</span>:</span></span><br><span class="line">    pivot_index = beg</span><br><span class="line">    pivot = seq[pivot_index]</span><br><span class="line">    left = pivot_index + <span class="number">1</span></span><br><span class="line">    right = end - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> seq[left] &lt; pivot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> seq[right] &gt;= pivot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            seq[left], seq[right] = seq[right], seq[left]</span><br><span class="line">    seq[pivot_index], seq[right] = seq[right], seq[pivot_index]</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort_inplace</span><span class="params">(seq, beg, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> beg &lt; end:</span><br><span class="line">        pivot = partition(seq, beg, end)</span><br><span class="line">        quick_sort_inplace(seq, beg, pivot)</span><br><span class="line">        quick_sort_inplace(seq, pivot + <span class="number">1</span>, end)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="两种排序算法的比较"><a href="#两种排序算法的比较" class="headerlink" title="两种排序算法的比较"></a>两种排序算法的比较</h2><table>
<thead>
<tr>
<th></th>
<th>原地排序</th>
<th>稳定排序</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>归并</td>
<td>否</td>
<td>是</td>
<td><code>O(nlogn)</code></td>
</tr>
<tr>
<td>快排</td>
<td>是</td>
<td>否</td>
<td><code>O(nlogn)</code></td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
  </entry>
  <entry>
    <title>python基本排序算法</title>
    <url>/2020/02/14/python%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>​        基本排序算法的原理及实现：冒泡排序(bubble_sort)，选择排序(select_sort)，插入排序(insert_sort)。</p>
<a id="more"></a>

<h1 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="思想原理"><a href="#思想原理" class="headerlink" title="思想原理"></a>思想原理</h3><ol>
<li>最简单的排序算法，没有之一。对输入的数组进行<code>n-1</code>轮的迭代(最后一轮已经是有序的了，不需要迭代，所以是<code>n-1</code>轮)。</li>
<li>每次比较相邻的两个元素，如果前者大于后者，将两者交换位置，因为是原地操作，所以空间复杂度为<code>O(1)</code>。</li>
<li>比如第一轮迭代，会将最大的元素移到数组末尾；第二轮会将第二大的元素移到次末尾；以此类推。</li>
<li>因为有两层迭代，所以时间复杂度是<code>O(n²)</code>。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - j - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> seq[i] &gt; seq[i + <span class="number">1</span>]:</span><br><span class="line">                seq[i], seq[i + <span class="number">1</span>] = seq[i + <span class="number">1</span>], seq[i]</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="思想原理-1"><a href="#思想原理-1" class="headerlink" title="思想原理"></a>思想原理</h3><ol>
<li>与冒泡排序类似，进行<code>n-1</code>轮迭代。</li>
<li>每一轮迭代中，选中某个元素，将该元素与它之后的所有元素进行比较，找出在该元素以及该元素之后的所有元素中最小的一个，将它与该元素交换位置，原地操作，空间复杂度<code>O(1)</code>。</li>
<li>比如第一轮迭代，选中数组中的第一个元素，将该元素与其他元素依次进行比较，选出最小的，与之交换；第二轮迭代，选中第二个元素，找出剩下最小的，与第二个元素交换；以此类推。</li>
<li>两层迭代，时间复杂度<code>O(n²)</code>。</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> seq[i] &lt; seq[j]:</span><br><span class="line">                min_index = i</span><br><span class="line">        <span class="keyword">if</span> min_index != j:</span><br><span class="line">            seq[j], seq[min_index] = seq[min_index], seq[j]</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="思想原理-2"><a href="#思想原理-2" class="headerlink" title="思想原理"></a>思想原理</h3><ol>
<li>对数组进行<code>n-1</code>次迭代，从第二个元素开始到最后一个元素。</li>
<li>每一轮迭代中，取出当前迭代的元素，将其与该元素之前的元素进行对比，直到碰到比该元素小的元素，将该元素插入到小元素之后，原地操作，空间复杂度<code>O(1)</code>。</li>
<li>比如，第一轮迭代，第二个元素比第一个元素小，插入到第一个元素前面，若比第一个元素大，则插入到后面；第二轮迭代，第三个元素比第二个元素小，比第一个大，则插入到中间，比第一个小，插入到第一个前面，比第二个大，插入到第二个后面；以此类推，第<code>n</code>次迭代，选取的是第<code>n+1</code>个元素，在此元素之前的元素都是已经排好序的，只需要找到合适的位置插入即可。</li>
<li>两层迭代，时间复杂度<code>O(n²)</code>。</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        value = seq[i]</span><br><span class="line">        pos = i</span><br><span class="line">        <span class="keyword">while</span> pos &gt; <span class="number">0</span> <span class="keyword">and</span> value &lt; seq[pos - <span class="number">1</span>]:</span><br><span class="line">            seq[pos] = seq[pos - <span class="number">1</span>]</span><br><span class="line">            pos -= <span class="number">1</span></span><br><span class="line">        seq[pos] = value</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="三种排序算法的比较"><a href="#三种排序算法的比较" class="headerlink" title="三种排序算法的比较"></a>三种排序算法的比较</h2><table>
<thead>
<tr>
<th></th>
<th>原地排序</th>
<th>稳定排序</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>是</td>
<td>是</td>
<td><code>O(n²)</code></td>
</tr>
<tr>
<td>选择</td>
<td>是</td>
<td>否</td>
<td><code>O(n²)</code></td>
</tr>
<tr>
<td>插入</td>
<td>是</td>
<td>是</td>
<td><code>O(n²)</code></td>
</tr>
</tbody></table>
<h3 id="稳定排序算法"><a href="#稳定排序算法" class="headerlink" title="稳定排序算法"></a>稳定排序算法</h3><p>在经过算法排序之后，被排序的对象里，相同的两个元素前后顺序没有发生改变，即为稳定的排序算法。</p>
<p>比如数组<code>[5, 8, 4, 5, 3]</code>的排序：</p>
<ul>
<li>冒泡排序算法，每次只相邻的两个元素比较交换位置，如果两个元素相等，则不交换位置，所以冒泡排序是稳定的排序算法。</li>
<li>选择排序算法，选定第一个<code>5</code>，<code>5</code>之后的元素中<code>3</code>最小，与<code>3</code>交换位置，此时第一个<code>5</code>被交换到了第二个<code>5</code>后面，两个相同的元素在经过排序之后，位置可能发生了改变，所以选择排序是不稳定的排序算法。</li>
<li>插入排序算法，对于先排序好的元素，后排序的元素选择插入到相同的元素后面，没有发生位置变化的可能，所以插入排序是稳定的排序算法。</li>
</ul>
<p>稳定排序算法优于不稳定算法的场景</p>
<blockquote>
<p>例如现在我们手上一堆(数量很大)订单，要把订单先按金额从小到大排序，再在金额相同的订单小区间内，对下单时间进行从早到晚的排序，实现起来了会很麻烦。但是使用稳定排序，第一次可以用随意的排序方法，对下单时间排序，下单早的在下单晚的前面，第二次再用稳定排序算法，对订单金额进行排序，此时，金额相同的区间内，下单早的还是在下单晚的前面。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之队列(Queue)</title>
    <url>/2019/12/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97(Queue)/</url>
    <content><![CDATA[<p>​        队列(Queue)也是一种操作受限的线性表，只允许在一端插入数据另一端删除数据，先进者先出，后进者后出，队列的数据操作也只有两种，入队<code>enqueue()</code>和出队<code>dequeue()</code>。队列可以用数组来实现，叫顺序队列，也可以用链表来实现，叫链式队列。</p>
<a id="more"></a>

<h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><table>
<thead>
<tr>
<th></th>
<th>顺序队列</th>
<th>链式队列</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td>出队</td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<p>不管是顺序队列还是链式队列，入队只涉及队列前后个别数据的操作，所以时间复杂度都是<code>O(1)</code>，但出队要从队列头删除元素，顺序队列后面的元素会整体发生偏移所以是<code>O(n)</code>。</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用之前数组文档中编写的<code>Array</code>类型，但是这个类型是固定长度的，要想支持动态扩容只能自己定义扩容的方法或者使用<code>list</code>类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self.queue = Array(maxsize)</span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> FullError(<span class="string">'queue full'</span>)</span><br><span class="line">        self.array[self.head % self.maxsize] = value</span><br><span class="line">        self.head += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = self.array[self.tail % self.maxsize]</span><br><span class="line">        self.tail += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.head - self.tail</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.queue:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array_queue</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">5</span></span><br><span class="line">    q = ArrayQueue(size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        q.push(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    q.push(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self._item_link_list = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._item_link_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span>    </span><br><span class="line">        <span class="string">""" 队尾添加元素 """</span></span><br><span class="line">        <span class="keyword">return</span> self._item_link_list.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""队列头部删除元素"""</span></span><br><span class="line">        <span class="keyword">if</span> len(self) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> EmptyError(<span class="string">'empty queue'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._item_link_list.popleft()</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list_queue</span><span class="params">()</span>:</span></span><br><span class="line">    q = LinkedListQueue()</span><br><span class="line">    q.push(<span class="number">0</span>)</span><br><span class="line">    q.push(<span class="number">1</span>)</span><br><span class="line">    q.push(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="用collections-deque实现"><a href="#用collections-deque实现" class="headerlink" title="用collections.deque实现"></a>用collections.deque实现</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>python数据结构之栈(Stack)</title>
    <url>/2019/11/15/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88(Stack)/</url>
    <content><![CDATA[<p>​        栈(Stack)是一种操作受限的线性表，只允许在一端插入和删除数据，先进者后出，后进者先出，栈的数据操作只有两种，入栈<code>push()</code>和出栈<code>pop()</code>。栈可以用数组来实现，叫顺序栈，也可以用链表来实现，叫链式栈。</p>
<a id="more"></a>

<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><table>
<thead>
<tr>
<th></th>
<th>顺序栈</th>
<th>链式栈</th>
</tr>
</thead>
<tbody><tr>
<td>入栈</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<p>不管是顺序栈还是链式栈，入栈和出栈都只涉及栈顶个别数据的操作，所以时间复杂度都是<code>O(1)</code>。</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用之前数组文档中编写的<code>Array</code>类型，但是这个类型是固定长度的，要想支持动态扩容只能自己定义扩容的方法或者使用<code>list</code>类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self.stack = Array(maxsize)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is full'</span>)</span><br><span class="line">        self.stack[self.count] = value</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is empty'</span>)</span><br><span class="line">        value = self.stack[(self.count - <span class="number">1</span>)]</span><br><span class="line">        self.stack[(self.count - <span class="number">1</span>)] = <span class="literal">None</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.stack:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array_stack</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">5</span></span><br><span class="line">    s = ArrayStack(size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        s.push(i)</span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    v = s.pop()</span><br><span class="line">    <span class="keyword">assert</span> v == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">    s.push(<span class="number">99</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">99</span>]</span><br></pre></td></tr></table></figure>



<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>直接继承之前链表文档中编写的<code>LinkedList</code>类型，因为已经有<code>append</code>方法了，只需要定义一个<code>pop</code>方法即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span><span class="params">(LinkedList)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is empty'</span>)</span><br><span class="line">        tailnode = self.tailnode</span><br><span class="line">        value = tailnode.value</span><br><span class="line">        self.remove(value)</span><br><span class="line">        <span class="keyword">return</span> tailnode.value</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list_stack</span><span class="params">()</span>:</span></span><br><span class="line">    s = LinkedListStack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    v = s.pop()</span><br><span class="line">    <span class="keyword">assert</span> v == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularDoubleLinkedListStack</span><span class="params">(CircularDoubleLinkedList)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is empty'</span>)</span><br><span class="line">        tailnode = self.tailnode()</span><br><span class="line">        value = tailnode.value</span><br><span class="line">        self.remove(tailnode)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-2"><a href="#单元测试-2" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_stack</span><span class="params">()</span>:</span></span><br><span class="line">    s = CircularDoubleLinkedListStack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    v = s.pop()</span><br><span class="line">    <span class="keyword">assert</span> v == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<h2 id="栈的实际应用"><a href="#栈的实际应用" class="headerlink" title="栈的实际应用"></a>栈的实际应用</h2><h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><blockquote>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成栈的结构，用来存储函数调用时的临时变量。</p>
<p>每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
</blockquote>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><ul>
<li>例如一个加减乘除四则运算，<code>34 + 13 * 9 + 44 - 12 / 3</code>。编译期通过两个栈来实现这个运算过程，一个保存操作数的栈，另一个保存运算符的栈。</li>
<li>从左往右遍历表达式，当遇到数字，我们就直接压入操作数栈；</li>
<li>当遇到运算符，就与运算符栈的栈顶元素进行比较。</li>
<li>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；</li>
<li>如果比运算符栈顶元素优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，进行计算后，再把运算的结果压入操作数栈，继续上述步骤。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之链表(Linked List)</title>
    <url>/2019/10/21/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8(LinkedList)/</url>
    <content><![CDATA[<p>​        链表(Lindked List)是一种链式数据结构。与数组相比，它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用，是可以无限扩容的。</p>
<a id="more"></a>

<h1 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h1><h2 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h2><p>常用的链表有三种：单向链表，双向链表和循环双向链表。</p>
<blockquote>
<p>单向链表的节点中只存储了数据和指向下一个节点的指针；</p>
<p>双向链表中还多存储了前一个节点的指针；</p>
<p>循环双向链表则是在双向链表的基础上，头节点的前指针指向尾节点，尾节点的后指针指向头节点，形成一个封闭的链表结构。</p>
</blockquote>
<h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>单向链表</th>
<th>双向链表</th>
</tr>
</thead>
<tbody><tr>
<td>向链表尾部新增元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>向链表头部新增元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>按值删除元素</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>按节点删除元素</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, next=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    链表 ADT： [root] -&gt; [node0] -&gt; [node1] -&gt; [node2]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self.root = Node()  <span class="comment"># 默认 root 节点为 None</span></span><br><span class="line">        self.tailnode = <span class="literal">None</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 在链表尾部新增一个节点，即将尾节点的指针指向新节点</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Linked list is full'</span>)</span><br><span class="line">        node = Node(value)</span><br><span class="line">        tailnode = self.tailnode</span><br><span class="line">        <span class="keyword">if</span> tailnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 说明此时链表为空链表</span></span><br><span class="line">            self.root.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tailnode.next = node</span><br><span class="line">        <span class="comment"># 更新尾节点为新节点</span></span><br><span class="line">        self.tailnode = node</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendleft</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 在链表头部新增一个节点，即将 root 节点的指针指向新节点，将新节点的指针指向头节点</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Linked list is full'</span>)</span><br><span class="line">        node = Node(value)</span><br><span class="line">        <span class="keyword">if</span> self.tailnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root.next = node</span><br><span class="line"></span><br><span class="line">        headnode = self.root.next</span><br><span class="line">        self.root.next = node.next</span><br><span class="line">        node.next = headnode</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">yield</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 不遍历 root 节点</span></span><br><span class="line">        curnode = self.root.next</span><br><span class="line">        <span class="keyword">while</span> curnode <span class="keyword">is</span> <span class="keyword">not</span> self.tailnode:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line">            curnode = curnode.next</span><br><span class="line">        <span class="comment"># 从 while 循环出来以后，还有最后一个节点没有遍历</span></span><br><span class="line">        <span class="keyword">if</span> curnode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 删除一个节点，即将该节点的前节点的指针指向该节点的下一个节点</span></span><br><span class="line">        prenode = self.root</span><br><span class="line">        <span class="keyword">for</span> curnode <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">if</span> curnode.value == value:</span><br><span class="line">                <span class="comment"># 找到指定节点后，更新前节点的指针</span></span><br><span class="line">                prenode.next = curnode.next</span><br><span class="line">                <span class="comment"># 如果删除的是尾节点的话还需要更新 tailnode</span></span><br><span class="line">                <span class="keyword">if</span> curnode <span class="keyword">is</span> self.tailnode:</span><br><span class="line">                    self.tailnode = prenode</span><br><span class="line">                <span class="keyword">del</span> curnode</span><br><span class="line">                self.length -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 表明删除成功</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prenode = curnode</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 表明删除失败</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 从头开始遍历，返回下标</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">if</span> node.value == value:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 表明没找到</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popleft</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 删除第一个节点，即把 root 指针指向头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.root.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'pop from empty Linked list'</span>)</span><br><span class="line">        headnode = self.root.next</span><br><span class="line">        self.root.next = headnode.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        value = headnode.value</span><br><span class="line">        <span class="comment"># 如果删除的是尾节点，则还需要更新 tailnode</span></span><br><span class="line">        <span class="keyword">if</span> self.tailnode <span class="keyword">is</span> headnode:</span><br><span class="line">            self.tailnode = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">del</span> headnode</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">del</span> node</span><br><span class="line">        self.root.next = <span class="literal">None</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        self.tailnode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 反转链表</span></span><br><span class="line">        curnode = self.root.next</span><br><span class="line">        <span class="comment"># 每次修改导致尾节点有变动的，都需要更新 tailnode</span></span><br><span class="line">        self.tailnode = curnode</span><br><span class="line">        prenode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curnode:</span><br><span class="line">            <span class="comment"># 把当前节点的下一个节点取出来</span></span><br><span class="line">            nextnode = curnode.next</span><br><span class="line">            <span class="comment"># 使当前节点的指针指向前节点</span></span><br><span class="line">            curnode.next = prenode</span><br><span class="line">            <span class="comment"># 当下节点为空时，说明已经到root节点了，此时nextnode就是root</span></span><br><span class="line">            <span class="keyword">if</span> nextnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root.next = curnode</span><br><span class="line"></span><br><span class="line">            prenode = curnode</span><br><span class="line">            curnode = nextnode</span><br></pre></td></tr></table></figure>

<h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list</span><span class="params">()</span>:</span></span><br><span class="line">    ll = LinkedList()</span><br><span class="line"></span><br><span class="line">    ll.append(<span class="number">0</span>)</span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> ll.find(<span class="number">2</span>) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> ll.find(<span class="number">-1</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> ll.remove(<span class="number">0</span>) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> ll.remove(<span class="number">10</span>) == <span class="number">-1</span></span><br><span class="line">    <span class="keyword">assert</span> ll.remove(<span class="number">2</span>) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">assert</span> ll.find(<span class="number">0</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    ll.appendleft(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    headvalue = ll.popleft()</span><br><span class="line">    <span class="keyword">assert</span> headvalue == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> ll.popleft() == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">3</span>]</span><br><span class="line">    ll.popleft()</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> ll.tailnode <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    ll.clear()</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list_reverse</span><span class="params">()</span>:</span></span><br><span class="line">    ll = LinkedList()</span><br><span class="line">    n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        ll.append(i)</span><br><span class="line">    ll.reverse()</span><br><span class="line">    <span class="keyword">assert</span> list(ll) == list(reversed(range(n)))</span><br></pre></td></tr></table></figure>



<h4 id="循环双向链表"><a href="#循环双向链表" class="headerlink" title="循环双向链表"></a>循环双向链表</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, prev=None, next=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularDoubleLinkedList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        node = Node()</span><br><span class="line">        node.prev, node.next = node, node</span><br><span class="line">        self.root = node</span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">headnode</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.root.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tailnode</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.root.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        向循环双端链表的尾部添加一个新的节点</span></span><br><span class="line"><span class="string">        1.定义一个 newnode</span></span><br><span class="line"><span class="string">        2.把当前的 tailnode 取出来</span></span><br><span class="line"><span class="string">        3.tailnode 的 next 指向 newnode</span></span><br><span class="line"><span class="string">        4.newnode 的 prev 指向 tailnode，next 指向 root</span></span><br><span class="line"><span class="string">        5.root 的 prev 指向 newnode</span></span><br><span class="line"><span class="string">        6.链表长度 length 加 1</span></span><br><span class="line"><span class="string">        注意边界判断，链表是否满了或者是否为空</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'LinkedList is Full'</span>)</span><br><span class="line">        newnode = Node(value=value)</span><br><span class="line">        tailnode = self.tailnode() <span class="keyword">or</span> self.root  <span class="comment"># 空链表时为 root</span></span><br><span class="line"></span><br><span class="line">        tailnode.next = newnode</span><br><span class="line">        newnode.prev = tailnode</span><br><span class="line">        newnode.next = self.root</span><br><span class="line">        self.root.prev = newnode</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendleft</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        向循环双端链表的头部添加一个新的节点</span></span><br><span class="line"><span class="string">        1.新建 newnode</span></span><br><span class="line"><span class="string">        2.取出 headnode</span></span><br><span class="line"><span class="string">        3.headnode 的 prev 指向 newnode</span></span><br><span class="line"><span class="string">        4.newnode 的 prev 指向 root，next 指向 headnode</span></span><br><span class="line"><span class="string">        5.root 的 next 指向newnode</span></span><br><span class="line"><span class="string">        6.长度加 1，边界判断，满或空</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'LinkedList is Full'</span>)</span><br><span class="line">        newnode = Node(value=value)</span><br><span class="line">        headnode = self.headnode() <span class="keyword">or</span> self.root</span><br><span class="line"></span><br><span class="line">        headnode.prev = newnode</span><br><span class="line">        newnode.prev = self.root</span><br><span class="line">        newnode.next = headnode</span><br><span class="line">        self.root.next = newnode</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, delnode)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        根据传入的节点删除对应的节点</span></span><br><span class="line"><span class="string">        1.nextnode 的 prev 指向 prevnode</span></span><br><span class="line"><span class="string">        2.prevnode 的 next 指向 nextnode</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> delnode <span class="keyword">is</span> self.root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nextnode = delnode.next</span><br><span class="line">            prenode = delnode.prev</span><br><span class="line">            nextnode.prev = prenode</span><br><span class="line">            prenode.next = nextnode</span><br><span class="line">            self.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 从头正向遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> self.root.next <span class="keyword">is</span> self.root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curnode = self.root.next</span><br><span class="line">        <span class="keyword">while</span> curnode.next <span class="keyword">is</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line">            curnode = curnode.next</span><br><span class="line">        <span class="keyword">yield</span> curnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">yield</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_node_reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 从尾反向遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> self.root.prev <span class="keyword">is</span> self.root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curnode = self.root.prev</span><br><span class="line">        <span class="keyword">while</span> curnode.prev <span class="keyword">is</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line">            curnode = curnode.prev</span><br><span class="line">        <span class="keyword">yield</span> curnode</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_double_linked_list</span><span class="params">()</span>:</span></span><br><span class="line">    cdll = CircularDoubleLinkedList()</span><br><span class="line">    <span class="keyword">assert</span> len(cdll) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    cdll.append(<span class="number">0</span>)</span><br><span class="line">    cdll.append(<span class="number">1</span>)</span><br><span class="line">    cdll.append(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(cdll) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    cdll.appendleft(<span class="number">3</span>)</span><br><span class="line">    cdll.appendleft(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(cdll) == [<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    headnode = cdll.headnode()</span><br><span class="line">    cdll.remove(headnode.next)</span><br><span class="line">    cdll.remove(headnode)</span><br><span class="line">    <span class="keyword">assert</span> list(cdll) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> [node.value <span class="keyword">for</span> node <span class="keyword">in</span> cdll.iter_node()] == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">assert</span> [node.value <span class="keyword">for</span> node <span class="keyword">in</span> cdll.iter_node_reverse()] == [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> len(cdll) == <span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之数组(Array)</title>
    <url>/2019/10/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84(Array)/</url>
    <content><![CDATA[<p>​        数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据，在定义时需要预先指定大小。</p>
<a id="more"></a>

<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><h2 id="最基础的数组"><a href="#最基础的数组" class="headerlink" title="最基础的数组"></a>最基础的数组</h2><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据，在定义时需要预先指定大小。</p>
<blockquote>
<p>线性表(Linear List中)，线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。</p>
<p>连续的内存空间和相同类型的数据，这两个限制，使得数组可以实现随机访问的特性，但也使很多操作变得低效，比如在数组中插入、删除一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
</blockquote>
<h3 id="数组的操作的及实现"><a href="#数组的操作的及实现" class="headerlink" title="数组的操作的及实现"></a>数组的操作的及实现</h3><p>我们假设有一个数组<code>a</code>，长度为<code>n</code>。</p>
<h4 id="根据下标随机访问"><a href="#根据下标随机访问" class="headerlink" title="根据下标随机访问"></a>根据下标随机访问</h4><p>数组支持随机访问，根据下标随机访问的时间复杂度为<code>O(1)</code></p>
<p>原理实现：计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会通过寻址公式，计算出该元素存储的内存地址，然后根据得到的内存地址，访问对应的元素，即通过计算偏移量就能取得元素，而不必遍历所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 寻址公式</span></span><br><span class="line"><span class="comment"># base_address 起始地址</span></span><br><span class="line"><span class="comment"># data_type_size 数组中每个元素的大小，数组只能存储同类型元素，所以每个元素的大小是相等的</span></span><br><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>排好序的数组，查找元素用二分查找，时间复杂度为<code>O(logn)</code></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设现在我们需要将一个数据插入到数组中的第k个位置。</p>
<blockquote>
<p>如果数组是有序的，为了把第k个位置腾出来给新来的元素，我们需要将第k~n这部分的元素都顺序的往后挪一位，时间复杂度为<code>O(n)</code>；</p>
<p>如果数组是无序的，为了避免大规模的数据搬移，我们可以直接把第k位的数据搬移到数组元素的最后，把新的元素放入第k个位置，时间复杂度为<code>O(1)</code></p>
</blockquote>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>与插入操作类似，把第k个位置的元素删除，为了内存的连续性，也需要搬移数据。</p>
<p>特殊处理：将多次删除的操作集中在一起执行，就不用每删除一个元素就搬移一次数据，而总共只需要搬移一次数据。</p>
<h2 id="python中的列表list"><a href="#python中的列表list" class="headerlink" title="python中的列表list"></a>python中的列表list</h2><p>python中也有<code>Array</code>类，但是因为其只能存同一类型数据，且只能存基础类型的数据，使用并不广泛。替代<code>Array</code>类进行日常开发使用的，是<code>list</code>类型。</p>
<h3 id="list常用内置方法"><a href="#list常用内置方法" class="headerlink" title="list常用内置方法"></a>list常用内置方法</h3><ul>
<li><code>list[index]</code>    按下标访问元素，时间复杂度<code>O(1)</code></li>
<li><code>list.append(obj)</code>    在列表末尾添加新的对象，<code>O(1)</code></li>
<li><code>list.insert(index, obj)</code>    在指定位置插入对象，<code>O(n)</code></li>
<li><code>list.pop(index)</code>    按下标删除元素，默认最后一位<code>O(1)</code>，不是最后一位则为<code>O(n)</code></li>
<li><code>list.remove(obj)</code>    删除指定元素，<code>O(n)</code></li>
</ul>
<h3 id="list的特点"><a href="#list的特点" class="headerlink" title="list的特点"></a>list的特点</h3><ol>
<li>列表可以存储不同类型的数据，它存储元素的方法是使用元素外置的方式，即存储的只是各个元素的地址，所以列表中的元素可以是不同类型的。</li>
<li>不必在定义时就指定大小，使用了动态扩容的策略。在python中，列表初始化时会申请一个存储四个元素的存储区，当存储区填满时，列表会再次申请四个存储空间存储元素。当元素量达到原存储空间的两倍时，列表会再次申请原来旧的存储空间的两倍的容量存储元素。</li>
</ol>
<h3 id="实现Array-ADT"><a href="#实现Array-ADT" class="headerlink" title="实现Array ADT"></a>实现Array ADT</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size=<span class="number">32</span>, init=None)</span>:</span></span><br><span class="line">        self._size = size</span><br><span class="line">        self._items = [init] * size</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[index]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        self._items[index] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self, value=None)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self._items)):</span><br><span class="line">            self._items[i] = value</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._items:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">10</span></span><br><span class="line">    a = Array(size)</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> a[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">assert</span> a[<span class="number">0</span>] <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Git常用指令</title>
    <url>/2019/06/03/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>​        Git是目前世界上最先进的分布式版本控制系统。</p>
<a id="more"></a>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>什么是分布式版本控制系统？</p>
<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。</p>
<p>那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<h2 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h2><p>git init  创建版本库</p>
<p>git add xxx  把文件加入到仓库</p>
<p>git commit -m “备注”  把之前加入到仓库的文件提交到仓库</p>
<p>git diff xxx  查看xxx文件具体修改了什么内容</p>
<p>git status  掌握仓库当前状态，什么被修改了，什么将要被提交</p>
<p>git log 显示从最近到最远的提交日志</p>
<p>​        –pretty oneline  使每一次的提交输出显示在一行内</p>
<p>git reset  版本回退命令</p>
<p>​        –hard HEAD(^表示上版本，^^表示上上版本，~100表示上100个版本，HEAD指向的版本就是当前版本)</p>
<p>​        –hard xxxx(xxxx为版本号，一长串可以不写全，回到指定版本)</p>
<p>git reflog  记录每一次改动命令，可以用于：回退了版本，但是又想回到回退前的版本，忘记了版本号，可以通过这个命令找到</p>
<p>git clone <a href="mailto:git@github.com">git@github.com</a>:sssusheng/xxx.git  在GitHub上可以任意Fork开源仓库，然后自己可以对自己Fork的仓库进行修改</p>
<h2 id="Git版本管理"><a href="#Git版本管理" class="headerlink" title="Git版本管理"></a>Git版本管理</h2><p>工作区(Working Directory)</p>
<p>​        在电脑里能直接看到的目录</p>
<p>版本库(Repository)</p>
<p>​        工作区中有一个隐藏目录 .git，是Git的版本库</p>
<p>​        版本库里重要的有：被称为stage(或index)的暂存区，Git为我们自动创建的第一个分支master，指向的master的一个指针HEAD</p>
<p>​        git add 把文件修改添加到暂存区</p>
<p>​        git commit 把暂存区的所有内容提交到当前分支</p>
<p>git checkout – xxx  把xxx文件在工作区的修改全部撤销</p>
<p>​        如果xxx修改后没有add，撤销回到版本库里的状态</p>
<p>​        如果xxx修改了add并再修改，撤销回到add后的状态</p>
<p>​        即让xxx回到最近一次commit或add时的状态</p>
<p>​        或者说是用版本库里的版本替换工作区的版本</p>
<p>git reset HEAD xxx  把add后还没提交的修改撤销</p>
<p>git rm xxx  从版本库中把xxx文件删除</p>
<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>在GitHub上创建远程仓库</p>
<p>①ssh-keygen -t rsa -C “<a href="mailto:sssusheng@qq.com">sssusheng@qq.com</a>“  创建SSH key</p>
<p>②登录GitHub，在设置里添加Add SSH key，把id_rsa.pub文件的内容粘贴进去</p>
<p>③在GitHub里创建一个空的仓库learngit</p>
<p>④git remote add origin <a href="mailto:git@github.com">git@github.com</a>:sssusheng/learngit.git  关联本地仓库</p>
<p>⑤git push -u origin master  把本地库的所有内容推送到远程库上</p>
<p>⑥git push origin master  可以把本地master分支的最新修改推送到Github</p>
<p>⑦git clone <a href="mailto:git@github.com">git@github.com</a>:sssusheng/learngit.git  把远程仓库克隆到本地</p>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p>分支：例如一个新功能开发需要两周，第一周做了一半，提交了不完整的代码，那么就会影响到其他人的工作，此时拉一个属于自己的分支，其他人看不到，直到开发完毕，再合并到原有分支上</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>①git switch -c dev  创建dev分支，并切换到dev分支</p>
<p>​        -c 表示创建并切换，不用-c是两条命令</p>
<p>​        git branch dev</p>
<p>​        git switch dev</p>
<p>②git branch  查看当前分支并列出所有分支</p>
<p>③git switch master  从dev分支切换回master分支</p>
<p>​        此时，在dev分支上提交的修改并没有合并到master分支上</p>
<p>④git merge dev  把dev分支的工作成果合并到master分支上</p>
<p>​        合并指定分支到当前分支，此时使用的是Fast forward模式，删除分支后，会丢掉分支信息</p>
<p>​        –no-ff  加入这个参数，禁用Fast forward模式，用普通模式合并，合并后可以在主分支上看出曾经做过合并操作</p>
<p>⑤git branch -d dev  删除dev分支</p>
<p>​        -D 强行删除</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当在两条分支上对同一个文件进行了不同的修改时，Git无法自动合并分支，必须要先解决冲突</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容再提交</p>
<p>git log –graph  可以看到分支合并图</p>
<h3 id="修复Bug"><a href="#修复Bug" class="headerlink" title="修复Bug"></a>修复Bug</h3><p>临时需要修复bug，需要拉一个bug-xxx的分支出来，但是自己的工作分支上的任务还没有完成</p>
<p>git stash  把当前工作现场储藏起来，等恢复现场后继续工作</p>
<p>bug修复之后，恢复工作现场</p>
<p>​    git stash list  查看储藏的工作现场</p>
<p>​    git stash apply + git stash drop = git stash pop</p>
<p>git cherry-pick <commit id>  在master分支上修复的bug，把修改同步到dev分支上，避免重复修改</p>
<h3 id="多人协同开发"><a href="#多人协同开发" class="headerlink" title="多人协同开发"></a>多人协同开发</h3><p>git remote -v  查看远程库信息</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的</p>
<p>git push origin branch-name  从本地推送分支</p>
<p>git pull  抓取远程最新提交</p>
<p>当本地分支推送失败时，先抓取最新提交，再试图合并，如果合并有冲突，先解决冲突，再推送</p>
<p>git pull 抓取失败，提示no tracking information，需要建立本地分支和远程分支的关联</p>
<p>git branch –set-upstream branch-name origin/branch-name</p>
<h2 id="Git标签管理"><a href="#Git标签管理" class="headerlink" title="Git标签管理"></a>Git标签管理</h2><p><commit id>是一堆乱七八糟的数字，难记难找</p>
<p>创建一个标签tag，和某一版本的commit关联起来，查找的时候对着tag找commit就方便了</p>
<p>git tag <tag name>  先切换到需要打标签的分支上，再创建标签</p>
<p>git tag  查看所有标签</p>
<p>git tag <tag name> <commit id>  指定在哪个commit上打标签</p>
<p>git tag -a <tag name> -m “备注”</p>
<p>git tag -d <tag name>   删除本地标签</p>
<p>git push origin :refs/tags/<tag name>  删除远程库标签</p>
<p>​        删除的时候，先删本地，再删远程</p>
<p>git push origin –tags  推送所有尚未推送的标签到远程</p>
<p>git push origin <tag name>  推送某一标签到远程</p>
]]></content>
  </entry>
</search>
