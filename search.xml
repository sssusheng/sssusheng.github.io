<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python基本排序算法</title>
    <url>/2020/02/14/python%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>​        基本排序算法的原理及实现：冒泡排序(bubble_sort)，选择排序(select_sort)，插入排序(insert_sort)。</p>
<a id="more"></a>

<h1 id="基本排序算法"><a href="#基本排序算法" class="headerlink" title="基本排序算法"></a>基本排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="思想原理"><a href="#思想原理" class="headerlink" title="思想原理"></a>思想原理</h3><ol>
<li>最简单的排序算法，没有之一。对输入的数组进行<code>n-1</code>轮的迭代(最后一轮已经是有序的了，不需要迭代，所以是<code>n-1</code>轮)。</li>
<li>每次比较相邻的两个元素，如果前者大于后者，将两者交换位置，因为是原地操作，所以空间复杂度为<code>O(1)</code>。</li>
<li>比如第一轮迭代，会将最大的元素移到数组末尾；第二轮会将第二大的元素移到次末尾；以此类推。</li>
<li>因为有两层迭代，所以时间复杂度是<code>O(n²)</code>。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - j - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> seq[i] &gt; seq[i + <span class="number">1</span>]:</span><br><span class="line">                seq[i], seq[i + <span class="number">1</span>] = seq[i + <span class="number">1</span>], seq[i]</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="思想原理-1"><a href="#思想原理-1" class="headerlink" title="思想原理"></a>思想原理</h3><ol>
<li>与冒泡排序类似，进行<code>n-1</code>轮迭代。</li>
<li>每一轮迭代中，选中某个元素，将该元素与它之后的所有元素进行比较，找出在该元素以及该元素之后的所有元素中最小的一个，将它与该元素交换位置，原地操作，空间复杂度<code>O(1)</code>。</li>
<li>比如第一轮迭代，选中数组中的第一个元素，将该元素与其他元素依次进行比较，选出最小的，与之交换；第二轮迭代，选中第二个元素，找出剩下最小的，与第二个元素交换；以此类推。</li>
<li>两层迭代，时间复杂度<code>O(n²)</code>。</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> seq[i] &lt; seq[j]:</span><br><span class="line">                min_index = i</span><br><span class="line">        <span class="keyword">if</span> min_index != j:</span><br><span class="line">            seq[j], seq[min_index] = seq[min_index], seq[j]</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="思想原理-2"><a href="#思想原理-2" class="headerlink" title="思想原理"></a>思想原理</h3><ol>
<li>对数组进行<code>n-1</code>次迭代，从第二个元素开始到最后一个元素。</li>
<li>每一轮迭代中，取出当前迭代的元素，将其与该元素之前的元素进行对比，直到碰到比该元素小的元素，将该元素插入到小元素之后，原地操作，空间复杂度<code>O(1)</code>。</li>
<li>比如，第一轮迭代，第二个元素比第一个元素小，插入到第一个元素前面，若比第一个元素大，则插入到后面；第二轮迭代，第三个元素比第二个元素小，比第一个大，则插入到中间，比第一个小，插入到第一个前面，比第二个大，插入到第二个后面；以此类推，第<code>n</code>次迭代，选取的是第<code>n+1</code>个元素，在此元素之前的元素都是已经排好序的，只需要找到合适的位置插入即可。</li>
<li>两层迭代，时间复杂度<code>O(n²)</code>。</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    n = len(seq)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        value = seq[i]</span><br><span class="line">        pos = i</span><br><span class="line">        <span class="keyword">while</span> pos &gt; <span class="number">0</span> <span class="keyword">and</span> value &lt; seq[pos - <span class="number">1</span>]:</span><br><span class="line">            seq[pos] = seq[pos - <span class="number">1</span>]</span><br><span class="line">            pos -= <span class="number">1</span></span><br><span class="line">        seq[pos] = value</span><br><span class="line">    <span class="keyword">return</span> seq</span><br></pre></td></tr></table></figure>

<h2 id="三种排序算法的比较"><a href="#三种排序算法的比较" class="headerlink" title="三种排序算法的比较"></a>三种排序算法的比较</h2><table>
<thead>
<tr>
<th></th>
<th>原地排序</th>
<th>稳定排序</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡</td>
<td>是</td>
<td>是</td>
<td><code>O(n²)</code></td>
</tr>
<tr>
<td>选择</td>
<td>是</td>
<td>否</td>
<td><code>O(n²)</code></td>
</tr>
<tr>
<td>插入</td>
<td>是</td>
<td>是</td>
<td><code>O(n²)</code></td>
</tr>
</tbody></table>
<h3 id="稳定排序算法"><a href="#稳定排序算法" class="headerlink" title="稳定排序算法"></a>稳定排序算法</h3><p>在经过算法排序之后，被排序的对象里，相同的两个元素前后顺序没有发生改变，即为稳定的排序算法。</p>
<p>比如数组<code>[5, 8, 4, 5, 3]</code>的排序：</p>
<ul>
<li>冒泡排序算法，每次只相邻的两个元素比较交换位置，如果两个元素相等，则不交换位置，所以冒泡排序是稳定的排序算法。</li>
<li>选择排序算法，选定第一个<code>5</code>，<code>5</code>之后的元素中<code>3</code>最小，与<code>3</code>交换位置，此时第一个<code>5</code>被交换到了第二个<code>5</code>后面，两个相同的元素在经过排序之后，位置可能发生了改变，所以选择排序是不稳定的排序算法。</li>
<li>插入排序算法，对于先排序好的元素，后排序的元素选择插入到相同的元素后面，没有发生位置变化的可能，所以插入排序是稳定的排序算法。</li>
</ul>
<p>稳定排序算法优于不稳定算法的场景</p>
<blockquote>
<p>例如现在我们手上一堆(数量很大)订单，要把订单先按金额从小到大排序，再在金额相同的订单小区间内，对下单时间进行从早到晚的排序，实现起来了会很麻烦。但是使用稳定排序，第一次可以用随意的排序方法，对下单时间排序，下单早的在下单晚的前面，第二次再用稳定排序算法，对订单金额进行排序，此时，金额相同的区间内，下单早的还是在下单晚的前面。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之队列(Queue)</title>
    <url>/2019/12/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97(Queue)/</url>
    <content><![CDATA[<p>​        队列(Queue)也是一种操作受限的线性表，只允许在一端插入数据另一端删除数据，先进者先出，后进者后出，队列的数据操作也只有两种，入队<code>enqueue()</code>和出队<code>dequeue()</code>。队列可以用数组来实现，叫顺序队列，也可以用链表来实现，叫链式队列。</p>
<a id="more"></a>

<h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><table>
<thead>
<tr>
<th></th>
<th>顺序队列</th>
<th>链式队列</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td>出队</td>
<td><code>O(n)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<p>不管是顺序队列还是链式队列，入队只涉及队列前后个别数据的操作，所以时间复杂度都是<code>O(1)</code>，但出队要从队列头删除元素，顺序队列后面的元素会整体发生偏移所以是<code>O(n)</code>。</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用之前数组文档中编写的<code>Array</code>类型，但是这个类型是固定长度的，要想支持动态扩容只能自己定义扩容的方法或者使用<code>list</code>类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self.queue = Array(maxsize)</span><br><span class="line">        self.head = <span class="number">0</span></span><br><span class="line">        self.tail = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> FullError(<span class="string">'queue full'</span>)</span><br><span class="line">        self.array[self.head % self.maxsize] = value</span><br><span class="line">        self.head += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        value = self.array[self.tail % self.maxsize]</span><br><span class="line">        self.tail += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.head - self.tail</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.queue:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array_queue</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">5</span></span><br><span class="line">    q = ArrayQueue(size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        q.push(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    q.push(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">0</span></span><br></pre></td></tr></table></figure>



<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self._item_link_list = LinkedList()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._item_link_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span>    </span><br><span class="line">        <span class="string">""" 队尾添加元素 """</span></span><br><span class="line">        <span class="keyword">return</span> self._item_link_list.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""队列头部删除元素"""</span></span><br><span class="line">        <span class="keyword">if</span> len(self) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> EmptyError(<span class="string">'empty queue'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._item_link_list.popleft()</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list_queue</span><span class="params">()</span>:</span></span><br><span class="line">    q = LinkedListQueue()</span><br><span class="line">    q.push(<span class="number">0</span>)</span><br><span class="line">    q.push(<span class="number">1</span>)</span><br><span class="line">    q.push(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> len(q) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> q.pop() == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="用collections-deque实现"><a href="#用collections-deque实现" class="headerlink" title="用collections.deque实现"></a>用collections.deque实现</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>python数据结构之栈(Stack)</title>
    <url>/2019/11/15/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88(Stack)/</url>
    <content><![CDATA[<p>​        栈(Stack)是一种操作受限的线性表，只允许在一端插入和删除数据，先进者后出，后进者先出，栈的数据操作只有两种，入栈<code>push()</code>和出栈<code>pop()</code>。栈可以用数组来实现，叫顺序栈，也可以用链表来实现，叫链式栈。</p>
<a id="more"></a>

<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><table>
<thead>
<tr>
<th></th>
<th>顺序栈</th>
<th>链式栈</th>
</tr>
</thead>
<tbody><tr>
<td>入栈</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td>出栈</td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
</tbody></table>
<p>不管是顺序栈还是链式栈，入栈和出栈都只涉及栈顶个别数据的操作，所以时间复杂度都是<code>O(1)</code>。</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>使用之前数组文档中编写的<code>Array</code>类型，但是这个类型是固定长度的，要想支持动态扩容只能自己定义扩容的方法或者使用<code>list</code>类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self.stack = Array(maxsize)</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is full'</span>)</span><br><span class="line">        self.stack[self.count] = value</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is empty'</span>)</span><br><span class="line">        value = self.stack[(self.count - <span class="number">1</span>)]</span><br><span class="line">        self.stack[(self.count - <span class="number">1</span>)] = <span class="literal">None</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.stack:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array_stack</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">5</span></span><br><span class="line">    s = ArrayStack(size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        s.push(i)</span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    v = s.pop()</span><br><span class="line">    <span class="keyword">assert</span> v == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">    s.push(<span class="number">99</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">99</span>]</span><br></pre></td></tr></table></figure>



<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>直接继承之前链表文档中编写的<code>LinkedList</code>类型，因为已经有<code>append</code>方法了，只需要定义一个<code>pop</code>方法即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span><span class="params">(LinkedList)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is empty'</span>)</span><br><span class="line">        tailnode = self.tailnode</span><br><span class="line">        value = tailnode.value</span><br><span class="line">        self.remove(value)</span><br><span class="line">        <span class="keyword">return</span> tailnode.value</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list_stack</span><span class="params">()</span>:</span></span><br><span class="line">    s = LinkedListStack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    v = s.pop()</span><br><span class="line">    <span class="keyword">assert</span> v == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularDoubleLinkedListStack</span><span class="params">(CircularDoubleLinkedList)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Stack is empty'</span>)</span><br><span class="line">        tailnode = self.tailnode()</span><br><span class="line">        value = tailnode.value</span><br><span class="line">        self.remove(tailnode)</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-2"><a href="#单元测试-2" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_stack</span><span class="params">()</span>:</span></span><br><span class="line">    s = CircularDoubleLinkedListStack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">2</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(s) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    v = s.pop()</span><br><span class="line">    <span class="keyword">assert</span> v == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> list(s) == [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<h2 id="栈的实际应用"><a href="#栈的实际应用" class="headerlink" title="栈的实际应用"></a>栈的实际应用</h2><h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><blockquote>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成栈的结构，用来存储函数调用时的临时变量。</p>
<p>每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
</blockquote>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><ul>
<li>例如一个加减乘除四则运算，<code>34 + 13 * 9 + 44 - 12 / 3</code>。编译期通过两个栈来实现这个运算过程，一个保存操作数的栈，另一个保存运算符的栈。</li>
<li>从左往右遍历表达式，当遇到数字，我们就直接压入操作数栈；</li>
<li>当遇到运算符，就与运算符栈的栈顶元素进行比较。</li>
<li>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；</li>
<li>如果比运算符栈顶元素优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，进行计算后，再把运算的结果压入操作数栈，继续上述步骤。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之链表(Linked List)</title>
    <url>/2019/10/21/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8(LinkedList)/</url>
    <content><![CDATA[<p>​        链表(Lindked List)是一种链式数据结构。与数组相比，它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用，是可以无限扩容的。</p>
<a id="more"></a>

<h1 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表(Linked List)"></a>链表(Linked List)</h1><h2 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h2><p>常用的链表有三种：单向链表，双向链表和循环双向链表。</p>
<blockquote>
<p>单向链表的节点中只存储了数据和指向下一个节点的指针；</p>
<p>双向链表中还多存储了前一个节点的指针；</p>
<p>循环双向链表则是在双向链表的基础上，头节点的前指针指向尾节点，尾节点的后指针指向头节点，形成一个封闭的链表结构。</p>
</blockquote>
<h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>单向链表</th>
<th>双向链表</th>
</tr>
</thead>
<tbody><tr>
<td>向链表尾部新增元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>向链表头部新增元素</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>按值删除元素</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>按节点删除元素</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, next=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    链表 ADT： [root] -&gt; [node0] -&gt; [node1] -&gt; [node2]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        self.root = Node()  <span class="comment"># 默认 root 节点为 None</span></span><br><span class="line">        self.tailnode = <span class="literal">None</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 在链表尾部新增一个节点，即将尾节点的指针指向新节点</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Linked list is full'</span>)</span><br><span class="line">        node = Node(value)</span><br><span class="line">        tailnode = self.tailnode</span><br><span class="line">        <span class="keyword">if</span> tailnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 说明此时链表为空链表</span></span><br><span class="line">            self.root.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tailnode.next = node</span><br><span class="line">        <span class="comment"># 更新尾节点为新节点</span></span><br><span class="line">        self.tailnode = node</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendleft</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 在链表头部新增一个节点，即将 root 节点的指针指向新节点，将新节点的指针指向头节点</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Linked list is full'</span>)</span><br><span class="line">        node = Node(value)</span><br><span class="line">        <span class="keyword">if</span> self.tailnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root.next = node</span><br><span class="line"></span><br><span class="line">        headnode = self.root.next</span><br><span class="line">        self.root.next = node.next</span><br><span class="line">        node.next = headnode</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">yield</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 不遍历 root 节点</span></span><br><span class="line">        curnode = self.root.next</span><br><span class="line">        <span class="keyword">while</span> curnode <span class="keyword">is</span> <span class="keyword">not</span> self.tailnode:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line">            curnode = curnode.next</span><br><span class="line">        <span class="comment"># 从 while 循环出来以后，还有最后一个节点没有遍历</span></span><br><span class="line">        <span class="keyword">if</span> curnode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 删除一个节点，即将该节点的前节点的指针指向该节点的下一个节点</span></span><br><span class="line">        prenode = self.root</span><br><span class="line">        <span class="keyword">for</span> curnode <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">if</span> curnode.value == value:</span><br><span class="line">                <span class="comment"># 找到指定节点后，更新前节点的指针</span></span><br><span class="line">                prenode.next = curnode.next</span><br><span class="line">                <span class="comment"># 如果删除的是尾节点的话还需要更新 tailnode</span></span><br><span class="line">                <span class="keyword">if</span> curnode <span class="keyword">is</span> self.tailnode:</span><br><span class="line">                    self.tailnode = prenode</span><br><span class="line">                <span class="keyword">del</span> curnode</span><br><span class="line">                self.length -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 表明删除成功</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prenode = curnode</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 表明删除失败</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># 从头开始遍历，返回下标</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">if</span> node.value == value:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 表明没找到</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">popleft</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 删除第一个节点，即把 root 指针指向头节点的下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> self.root.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'pop from empty Linked list'</span>)</span><br><span class="line">        headnode = self.root.next</span><br><span class="line">        self.root.next = headnode.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        value = headnode.value</span><br><span class="line">        <span class="comment"># 如果删除的是尾节点，则还需要更新 tailnode</span></span><br><span class="line">        <span class="keyword">if</span> self.tailnode <span class="keyword">is</span> headnode:</span><br><span class="line">            self.tailnode = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">del</span> headnode</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">del</span> node</span><br><span class="line">        self.root.next = <span class="literal">None</span></span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line">        self.tailnode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 反转链表</span></span><br><span class="line">        curnode = self.root.next</span><br><span class="line">        <span class="comment"># 每次修改导致尾节点有变动的，都需要更新 tailnode</span></span><br><span class="line">        self.tailnode = curnode</span><br><span class="line">        prenode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curnode:</span><br><span class="line">            <span class="comment"># 把当前节点的下一个节点取出来</span></span><br><span class="line">            nextnode = curnode.next</span><br><span class="line">            <span class="comment"># 使当前节点的指针指向前节点</span></span><br><span class="line">            curnode.next = prenode</span><br><span class="line">            <span class="comment"># 当下节点为空时，说明已经到root节点了，此时nextnode就是root</span></span><br><span class="line">            <span class="keyword">if</span> nextnode <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.root.next = curnode</span><br><span class="line"></span><br><span class="line">            prenode = curnode</span><br><span class="line">            curnode = nextnode</span><br></pre></td></tr></table></figure>

<h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list</span><span class="params">()</span>:</span></span><br><span class="line">    ll = LinkedList()</span><br><span class="line"></span><br><span class="line">    ll.append(<span class="number">0</span>)</span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> ll.find(<span class="number">2</span>) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> ll.find(<span class="number">-1</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> ll.remove(<span class="number">0</span>) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> ll.remove(<span class="number">10</span>) == <span class="number">-1</span></span><br><span class="line">    <span class="keyword">assert</span> ll.remove(<span class="number">2</span>) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">assert</span> ll.find(<span class="number">0</span>) == <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    ll.appendleft(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    headvalue = ll.popleft()</span><br><span class="line">    <span class="keyword">assert</span> headvalue == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> ll.popleft() == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == [<span class="number">3</span>]</span><br><span class="line">    ll.popleft()</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> ll.tailnode <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    ll.clear()</span><br><span class="line">    <span class="keyword">assert</span> len(ll) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">assert</span> list(ll) == []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_linked_list_reverse</span><span class="params">()</span>:</span></span><br><span class="line">    ll = LinkedList()</span><br><span class="line">    n = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        ll.append(i)</span><br><span class="line">    ll.reverse()</span><br><span class="line">    <span class="keyword">assert</span> list(ll) == list(reversed(range(n)))</span><br></pre></td></tr></table></figure>



<h4 id="循环双向链表"><a href="#循环双向链表" class="headerlink" title="循环双向链表"></a>循环双向链表</h4><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, prev=None, next=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularDoubleLinkedList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line">        node = Node()</span><br><span class="line">        node.prev, node.next = node, node</span><br><span class="line">        self.root = node</span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">headnode</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.root.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tailnode</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.root.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        向循环双端链表的尾部添加一个新的节点</span></span><br><span class="line"><span class="string">        1.定义一个 newnode</span></span><br><span class="line"><span class="string">        2.把当前的 tailnode 取出来</span></span><br><span class="line"><span class="string">        3.tailnode 的 next 指向 newnode</span></span><br><span class="line"><span class="string">        4.newnode 的 prev 指向 tailnode，next 指向 root</span></span><br><span class="line"><span class="string">        5.root 的 prev 指向 newnode</span></span><br><span class="line"><span class="string">        6.链表长度 length 加 1</span></span><br><span class="line"><span class="string">        注意边界判断，链表是否满了或者是否为空</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'LinkedList is Full'</span>)</span><br><span class="line">        newnode = Node(value=value)</span><br><span class="line">        tailnode = self.tailnode() <span class="keyword">or</span> self.root  <span class="comment"># 空链表时为 root</span></span><br><span class="line"></span><br><span class="line">        tailnode.next = newnode</span><br><span class="line">        newnode.prev = tailnode</span><br><span class="line">        newnode.next = self.root</span><br><span class="line">        self.root.prev = newnode</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendleft</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        向循环双端链表的头部添加一个新的节点</span></span><br><span class="line"><span class="string">        1.新建 newnode</span></span><br><span class="line"><span class="string">        2.取出 headnode</span></span><br><span class="line"><span class="string">        3.headnode 的 prev 指向 newnode</span></span><br><span class="line"><span class="string">        4.newnode 的 prev 指向 root，next 指向 headnode</span></span><br><span class="line"><span class="string">        5.root 的 next 指向newnode</span></span><br><span class="line"><span class="string">        6.长度加 1，边界判断，满或空</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> len(self) &gt;= self.maxsize:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'LinkedList is Full'</span>)</span><br><span class="line">        newnode = Node(value=value)</span><br><span class="line">        headnode = self.headnode() <span class="keyword">or</span> self.root</span><br><span class="line"></span><br><span class="line">        headnode.prev = newnode</span><br><span class="line">        newnode.prev = self.root</span><br><span class="line">        newnode.next = headnode</span><br><span class="line">        self.root.next = newnode</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, delnode)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        根据传入的节点删除对应的节点</span></span><br><span class="line"><span class="string">        1.nextnode 的 prev 指向 prevnode</span></span><br><span class="line"><span class="string">        2.prevnode 的 next 指向 nextnode</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> delnode <span class="keyword">is</span> self.root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nextnode = delnode.next</span><br><span class="line">            prenode = delnode.prev</span><br><span class="line">            nextnode.prev = prenode</span><br><span class="line">            prenode.next = nextnode</span><br><span class="line">            self.length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_node</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 从头正向遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> self.root.next <span class="keyword">is</span> self.root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curnode = self.root.next</span><br><span class="line">        <span class="keyword">while</span> curnode.next <span class="keyword">is</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line">            curnode = curnode.next</span><br><span class="line">        <span class="keyword">yield</span> curnode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.iter_node():</span><br><span class="line">            <span class="keyword">yield</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter_node_reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 从尾反向遍历链表</span></span><br><span class="line">        <span class="keyword">if</span> self.root.prev <span class="keyword">is</span> self.root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curnode = self.root.prev</span><br><span class="line">        <span class="keyword">while</span> curnode.prev <span class="keyword">is</span> <span class="keyword">not</span> self.root:</span><br><span class="line">            <span class="keyword">yield</span> curnode</span><br><span class="line">            curnode = curnode.prev</span><br><span class="line">        <span class="keyword">yield</span> curnode</span><br></pre></td></tr></table></figure>

<h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_double_linked_list</span><span class="params">()</span>:</span></span><br><span class="line">    cdll = CircularDoubleLinkedList()</span><br><span class="line">    <span class="keyword">assert</span> len(cdll) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    cdll.append(<span class="number">0</span>)</span><br><span class="line">    cdll.append(<span class="number">1</span>)</span><br><span class="line">    cdll.append(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(cdll) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    cdll.appendleft(<span class="number">3</span>)</span><br><span class="line">    cdll.appendleft(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">assert</span> list(cdll) == [<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    headnode = cdll.headnode()</span><br><span class="line">    cdll.remove(headnode.next)</span><br><span class="line">    cdll.remove(headnode)</span><br><span class="line">    <span class="keyword">assert</span> list(cdll) == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> [node.value <span class="keyword">for</span> node <span class="keyword">in</span> cdll.iter_node()] == [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">assert</span> [node.value <span class="keyword">for</span> node <span class="keyword">in</span> cdll.iter_node_reverse()] == [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">assert</span> len(cdll) == <span class="number">3</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>python数据结构之数组(Array)</title>
    <url>/2019/10/09/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84(Array)/</url>
    <content><![CDATA[<p>​        数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据，在定义时需要预先指定大小。</p>
<a id="more"></a>

<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h1><h2 id="最基础的数组"><a href="#最基础的数组" class="headerlink" title="最基础的数组"></a>最基础的数组</h2><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><p>数组(Array)是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据，在定义时需要预先指定大小。</p>
<blockquote>
<p>线性表(Linear List中)，线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。</p>
<p>连续的内存空间和相同类型的数据，这两个限制，使得数组可以实现随机访问的特性，但也使很多操作变得低效，比如在数组中插入、删除一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
</blockquote>
<h3 id="数组的操作的及实现"><a href="#数组的操作的及实现" class="headerlink" title="数组的操作的及实现"></a>数组的操作的及实现</h3><p>我们假设有一个数组<code>a</code>，长度为<code>n</code>。</p>
<h4 id="根据下标随机访问"><a href="#根据下标随机访问" class="headerlink" title="根据下标随机访问"></a>根据下标随机访问</h4><p>数组支持随机访问，根据下标随机访问的时间复杂度为<code>O(1)</code></p>
<p>原理实现：计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会通过寻址公式，计算出该元素存储的内存地址，然后根据得到的内存地址，访问对应的元素，即通过计算偏移量就能取得元素，而不必遍历所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 寻址公式</span></span><br><span class="line"><span class="comment"># base_address 起始地址</span></span><br><span class="line"><span class="comment"># data_type_size 数组中每个元素的大小，数组只能存储同类型元素，所以每个元素的大小是相等的</span></span><br><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>排好序的数组，查找元素用二分查找，时间复杂度为<code>O(logn)</code></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设现在我们需要将一个数据插入到数组中的第k个位置。</p>
<blockquote>
<p>如果数组是有序的，为了把第k个位置腾出来给新来的元素，我们需要将第k~n这部分的元素都顺序的往后挪一位，时间复杂度为<code>O(n)</code>；</p>
<p>如果数组是无序的，为了避免大规模的数据搬移，我们可以直接把第k位的数据搬移到数组元素的最后，把新的元素放入第k个位置，时间复杂度为<code>O(1)</code></p>
</blockquote>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>与插入操作类似，把第k个位置的元素删除，为了内存的连续性，也需要搬移数据。</p>
<p>特殊处理：将多次删除的操作集中在一起执行，就不用每删除一个元素就搬移一次数据，而总共只需要搬移一次数据。</p>
<h2 id="python中的列表list"><a href="#python中的列表list" class="headerlink" title="python中的列表list"></a>python中的列表list</h2><p>python中也有<code>Array</code>类，但是因为其只能存同一类型数据，且只能存基础类型的数据，使用并不广泛。替代<code>Array</code>类进行日常开发使用的，是<code>list</code>类型。</p>
<h3 id="list常用内置方法"><a href="#list常用内置方法" class="headerlink" title="list常用内置方法"></a>list常用内置方法</h3><ul>
<li><code>list[index]</code>    按下标访问元素，时间复杂度<code>O(1)</code></li>
<li><code>list.append(obj)</code>    在列表末尾添加新的对象，<code>O(1)</code></li>
<li><code>list.insert(index, obj)</code>    在指定位置插入对象，<code>O(n)</code></li>
<li><code>list.pop(index)</code>    按下标删除元素，默认最后一位<code>O(1)</code>，不是最后一位则为<code>O(n)</code></li>
<li><code>list.remove(obj)</code>    删除指定元素，<code>O(n)</code></li>
</ul>
<h3 id="list的特点"><a href="#list的特点" class="headerlink" title="list的特点"></a>list的特点</h3><ol>
<li>列表可以存储不同类型的数据，它存储元素的方法是使用元素外置的方式，即存储的只是各个元素的地址，所以列表中的元素可以是不同类型的。</li>
<li>不必在定义时就指定大小，使用了动态扩容的策略。在python中，列表初始化时会申请一个存储四个元素的存储区，当存储区填满时，列表会再次申请四个存储空间存储元素。当元素量达到原存储空间的两倍时，列表会再次申请原来旧的存储空间的两倍的容量存储元素。</li>
</ol>
<h3 id="实现Array-ADT"><a href="#实现Array-ADT" class="headerlink" title="实现Array ADT"></a>实现Array ADT</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size=<span class="number">32</span>, init=None)</span>:</span></span><br><span class="line">        self._size = size</span><br><span class="line">        self._items = [init] * size</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._items[index]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, value)</span>:</span></span><br><span class="line">        self._items[index] = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._size</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self, value=None)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self._items)):</span><br><span class="line">            self._items[i] = value</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._items:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_array</span><span class="params">()</span>:</span></span><br><span class="line">    size = <span class="number">10</span></span><br><span class="line">    a = Array(size)</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> a[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    a.clear()</span><br><span class="line">    <span class="keyword">assert</span> a[<span class="number">0</span>] <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
